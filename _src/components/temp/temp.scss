.color_list_container {
    display: block;
    border-top: 1px solid #ddd;
    padding: .375rem 1.125rem 0 .75rem;
    overflow: hidden;
    flex: 0 1 100%;
}

.color_list_toggle.color_list_collapsed {
    &:hover {
        background-color: rgba(#E3F1F9, .5);
        border-color: #E3F1F9;
    }
    &:active {
        background-color: rgba(#E3F1F9, .75);
    }
}

.color_list {
    font-size: 13 / 16 * 1rem;
    width: 100%;
    max-height: 20rem;
    border-radius: 4px;
    overflow: hidden;
    transform-origin: left top;
    transition: border-radius 200ms ease-out;
    display: flex;
    align-items: stretch;
    outline: none;
    margin-top: .75rem;
    margin-left: 0;
    margin-bottom: .75rem;
    max-width: 100%;
    max-height: 245 / 16 * 1rem;

    &:focus {
        outline: none;
    }
}

.color_list.color_list_collapsed {
    border-radius: .5rem;
    height: .375rem;
    margin-left: 2.5rem;
    margin-top: .1rem;
    max-width: 16rem;
    width: calc(100% - 2.5rem);

    .color_list_wrapper {
        transform: rotateZ(90deg) translateY(50%) translateX(0px);
        width: 100%;
    }
}

.color_list_text {
    opacity: .95;
    z-index: 0;
    transition: opacity 300ms ease-in, transform 400ms ease-out;
    transition-delay: 75ms;
    display: inline-flex;
    white-space: nowrap;
    outline: none;
    width: 100%;
    transform: translateY(0%);

    &:focus {
        outline: none;
    }

    .color_list_collapsed .color_list & {
        opacity: 0;
        transition-duration: 25ms;
        transition-delay: 0s;
        transform: translateY(20%);
    }
}

.color_list_wrapper {
    transform-origin: 0% 50%;
    max-width: 100%;
    width: 100%;
    overflow: hidden;
    display: flex;
    align-items: stretch;
    flex-direction: column;
    min-height: 10rem;
}

.color_list_item {
    padding: .5rem;
    position: relative;
    flex: 1 1 auto;
    max-height: 2.125rem;
    transition: max-height 250ms ease-out;

    @for $i from 10 through 1 {
        &:nth-child(#{$i}) {
            transition-duration: #{(($i + 100) * 2.5) * 1ms};
        }
    }

    .color_list_collapsed .color_list & {
        max-height: 6rem;
        transition-delay: 0;
    }
}

.color_list_item:before {
    content: '';
    position: absolute;
    left: 0;
    width: 100%;
    right: 0;
    top: 0;
    bottom: 0;
    opacity: .35;
    z-index: 1;
    transition: opacity 300ms ease-out;

    .color_list_collapsed .color_list & {
        opacity: .65;
    }
}

.color_list .color_list_item {
    color: #031523;
}

.color_list_item .color_list_icon {
    margin-top: 0;
}

.color_list_item .color_list_icon:before {
    display: inline-block;
    margin-right: .75rem;
    margin-left: -.1em;
    width: 1.5em;
    text-align: center;
}

.color_list_green {
    .color_list_icon:before {
        content: "\e626";
        color: #39BB7C;
    }
}

.color_list_yellow {
    .color_list_icon:before {
        content: "\e65e";
        color: #E1BB4F;
    }
}

.color_list_red {
    .color_list_icon:before {
        content: "\e63f";
        color: #b53e3e;
    }
}

.color_list_green:before {
    background: #39BB7C;
}

.color_list_yellow:before {
    background: #E1BB4F;
}

.color_list_red:before {
    background: #b53e3e;
}

.color_circle:before {
    width: 2.25rem;
    height: 2.25rem;
    border-radius: 100%;
    right: auto;
    top: .2rem;
    left: -.2rem;
    opacity: .35;
}

.color_circle {
    margin-left: -.1rem;
}

.color_circle .color_list_icon:before {
    margin-right: .75rem;
    text-align: left;
}

.color_list_title {
    position: relative;
}

.color_list_toggle_icon {
    position:  absolute;
    right: -1.75em;
    margin-top: -.375em;
    text-align: center;
    background-color: white;
    border-radius: 100%;
    padding-top: .25rem;
    width: 2rem;
    height: 2rem;


    &:before {
        transform: scaleY(-1);
        opacity: .6;
        transition: transform 400ms ease-out;

        .color_list_collapsed & {
            transform: scaleY(1);
            opacity: .7;
            transition-duration: 200ms;
        }
    }
}

.color_list_toggle_icon:before {
    display: inline-block;
    content: "\e629";
}

.box_color_list {
    padding: 0;
    min-height: 330 / 16 * 1rem;
    display: flex;
    flex-wrap: wrap;
    align-items: flex-start;
    align-content: flex-start;
}

.color_list_header {
    padding: .75rem;
    color: #9da9b3;
    flex: 0 1 100%;
}

.color_list_footer {
    padding: .75rem 1.5rem .75rem .75rem;
    border-top: 1px solid #ddd;
    flex: 0 1 100%;
    align-self: flex-end;
}

.color_list .color_list_text.color_list_icon {
    padding-top: .05em;
}

.modal.open {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    height: 100vh;
    z-index: 1000;
    background-color: rgba(#031523, .2);
    display: flex;
    justify-content: center;
    align-items: center;
    opacity: 1;
    transition: opacity 100ms ease-out;
}

.modal {
    opacity: 0;
}

.modal_wrapper {
    max-width: 100%;

    img {
        max-width: 100%;
    }
}

.column {
    flex: 0 1 auto;
}

// @calc-bezier-x($x1, $y1, $x2, $y2) {
//     @return (1-t)^3 * x0 + 3*(1-t)^2 * t * x1 + 3*(1-t) * t^2 * x2 + t^3 * x3;
// }

// @function A ($aA1, $aA2) { @return 1.0 - 3.0 * $aA2 + 3.0 * $aA1; }
// @function B ($aA1, $aA2) { @return 3.0 * $aA2 - 6.0 * $aA1; }
// @function C ($aA1)      { @return 3.0 * $aA1; }
// @function calcBezier ($aT, $aA1, $aA2) {
//     @return ((A($aA1, $aA2)*$aT + B($aA1, $aA2))*$aT + C($aA1))*$aT;
// }
// @function getSlope ($aT, $aA1, $aA2) {
//     @return 3.0 * A($aA1, $aA2)*$aT*$aT + 2.0 * B($aA1, $aA2) * $aT + C($aA1);
// }

// @function bezier($mX1, $mY1, $mX2, $mY2) {
//         $NEWTON_ITERATIONS: 4;
//         $NEWTON_MIN_SLOPE: 0.001;
//         $SUBDIVISION_PRECISION: 0.0000001;
//         $SUBDIVISION_MAX_ITERATIONS: 10;
//         $kSplineTableSize: 11;
//         $kSampleStepSize: 1.0 / ($kSplineTableSize - 1.0);
//         $float32ArraySupported: false;

//         /* X values must be in the [0, 1] range. */
//         $mX1: min(mX1, 1);
//         $mX2: min(mX2, 1);
//         $mX1: max(mX1, 0);
//         $mX2: max(mX2, 0);

//         $mSampleValues: (0,0,0,0,0,0,0,0,0,0,0);






//         @function newtonRaphsonIterate (aX, aGuessT) {
//             for ($i: 0; i < $NEWTON_ITERATIONS; ++i) {
//                 $currentSlope: getSlope($aGuessT, $mX1, $mX2);

//                 if ($currentSlope === 0.0) @return $aGuessT;

//                 $currentX: calcBezier(aGuessT, mX1, mX2) - $aX;
//                 $aGuessT: $aGuessT - (currentX / currentSlope);
//             }

//             return $aGuessT;
//         }

//         @function calcSampleValues () {
//             for ($i: 0; i < kSplineTableSize; ++i) {
//                 mSampleValues[i]: calcBezier(i * kSampleStepSize, mX1, mX2);
//             }
//         }

//         @function binarySubdivide ($aX, $aA, $aB) {
//             $currentX:null; $currentT:null; $i: 0;

//             @while (abs($currentX) > $SUBDIVISION_PRECISION && $i+1 < $SUBDIVISION_MAX_ITERATIONS) {
//                 $currentT: $aA + ($aB - $aA) / 2.0;
//                 $currentX: calcBezier($currentT, $mX1, $mX2) - $aX;
//                 @if ($currentX > 0.0) {
//                   $aB: $currentT;
//                 } @else {
//                   $aA: $currentT;
//                 }
//             }

//             @return $currentT;
//         }

//         @function getTForX ($aX) {
//             $intervalStart: 0.0,
//                 $currentSample: 1,
//                 $lastSample: $kSplineTableSize - 1;

//             for (; currentSample != lastSample && mSampleValues[currentSample] <= aX; ++currentSample) {
//                 intervalStart += kSampleStepSize;
//             }

//             --currentSample;

//             $dist: (aX - mSampleValues[currentSample]) / (mSampleValues[currentSample+1] - mSampleValues[currentSample]),
//                 guessForT: intervalStart + dist * kSampleStepSize,
//                 initialSlope: getSlope(guessForT, mX1, mX2);

//             if (initialSlope >= NEWTON_MIN_SLOPE) {
//                 return newtonRaphsonIterate(aX, guessForT);
//             } else if (initialSlope == 0.0) {
//                 return guessForT;
//             } else {
//                 return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize);
//             }
//         }

//         $_precomputed: false;

//         function precompute() {
//             _precomputed: true;
//             if (mX1 != mY1 || mX2 != mY2) calcSampleValues();
//         }

//         $f: function (aX) {
//             if (!_precomputed) precompute();
//             if (mX1 === mY1 && mX2 === mY2) return aX;
//             if (aX === 0) return 0;
//             if (aX === 1) return 1;

//             return calcBezier(getTForX(aX), mY1, mY2);
//         };

//         return f;
//     }
