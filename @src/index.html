<!-- doctype, html, and body are strings
    to prevent svelte from evaluating them -->
{ @html
    `<!DOCTYPE html>
    <html lang="en" itemscope itemtype="https://schema.org/Article">`
}
{ @html header }
{ @html '<body>' }
    { @html bodyHtmlSnippet }
    <div id="app" class="application">
        { @html appHtmlSnippet }
        {#if appComponent}
            { @html renderedComponent }
        {/if}
    </div>
    <Footer></Footer>
    { @html exportedState }
{ @html `
    </body></html>
` }

<script>
import HeadTemplate from '@/components/head';
import Footer from '@/components/footer?ssr';
import webmanifest from '@/manifest.webmanifest';
import browserConfig from '@/browserconfig.xml';

export default {
    components: { Footer },
    data: () => ({
        appComponent: null,
        fileManifest: {},
        googleAnalytics: null,
        meta: [],
        links: [],
        inlineStyle: '',
        scripts: [],
        webmanifest: webmanifest,
        browserConfig: browserConfig,
        title: 'Front-End-Framework',
        headHtmlSnippet: '',
        appHtmlSnippet: '',
        bodyHtmlSnippet: '',
        fromServer: {
            pathname: '/',
            componentPath: '/',
            request: {},
        },
    }),
    helpers: {},
    computed: {
        // Convenient way to pass entire state to components
        props: (state) => state,

        // Get initial scripts from manifest, if they exist
        // (filter out hot-module-replacement updates)
        manifestScripts: ({ fileManifest }) =>
            fileManifest.initial &&
            fileManifest.initial.filter(
                (script) => script.indexOf('hot-update') < 0
            ),

        // Pass head state to handlebars template
        header: (state) => HeadTemplate(state),

        // Add the initial page state to the window,
        // Allowing our app to hydrate
        exportedState: ({ fromServer, fileManifest }) => {
            let { pathname, componentPath, request } = fromServer;
            request = request
                ? {
                      url: request.url,
                      headers: request.headers,
                      method: request.method,
                  }
                : '""';
            return (
                `<script>` +
                `console.log('Manifest', ${JSON.stringify(fileManifest)});` +
                `window.__APP_STATE__ = { ` +
                `  initialRoute: "${pathname}",` +
                `  componentPath: "${componentPath}",` +
                `  request: ${JSON.stringify(request)}` +
                `};` +
                // eslint-disable-next-line
                `<\/script>`
            );
        },

        // Get processed svelte template and evaluate it
        // in a separate node VM (eval)
        // Allows us to avoid bundling every possible page template
        renderedComponent: (state) => {
            if (!state.appComponent) return '';
            return state.appComponent.render(state);
            // if (!state.asset) {
            //     const _eval = __non_webpack_require__('eval');
            //
            //     let { htmlWebpackPlugin, compilation } = state;
            //
            //     const assetName =
            //         htmlWebpackPlugin.options.render.internalTemplate;
            //
            //     if (!assetName) {
            //         return '';
            //     }
            //
            //     try {
            //         const source = compilation.assets[assetName].toSource();
            //         const context = _eval(
            //             source,
            //             assetName,
            //             {
            //                 window: undefined,
            //                 document: undefined,
            //                 fetch: undefined,
            //             },
            //             false /* Do not include node globals */
            //         );
            //         return context.render(state);
            //     } catch (e) {
            //         // eslint-disable-next-line
            //         console.log(e);
            //         return 'error: ' + e.message;
            //     }
            // }
            // console.log(asset);
        },
    },
};
</script>
