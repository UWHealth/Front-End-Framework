{@html
    `<!DOCTYPE html>
    <html lang="en">`
}
{@html header}
{@html '<body>'}
    <div id="app" class="application">
        {@html innerComponent}
    </div>
    {@html addon}
    {@html pageState}
{@html '</body></html>'}

<script>
import header from '@/components/header/_header.hbs';
import footer from '@/components/footer/_footer.hbs';
// Node imports
//const CACHE_BUSTER = new Date().getTime();
// const manifestPath = preval`
//     const path = require('path');
//     const manifestPath = require(
//         process.cwd() + '/config/paths.config.js'
//     ).demos.entry.manifest;
//     const regEx = new RegExp('/\\\\/', 'g');
//     const rel = path.relative(
//         process.cwd(),
//         path.resolve(manifestPath)
//     );
//     module.exports = path.normalize('/' + rel.replace(regEx, '/'))`;
//console.log(manifestPathz);
import manifest from '@manifest';

// const manifest = preval`
//     const cache = new Date().getTime();
//     const fs = require('fs');
//     const PATHS = require(process.cwd() + '/config/paths.config.js');
//     const manifest = fs.readFileSync(PATHS.demos.entry.manifest, 'utf-8');
//     module.exports = JSON.parse(manifest);`;

// doctype, html, body, and head tags added as strings
// to prevent Svelte from treating them as components
export default {
    data: () => ({
        htmlWebpackPlugin: null,
        compilation: '',
        manifest: manifest,
        publicPath: __webpack_public_path__,
    }),

    computed: {
        // Convert htmlWebpackPlugin options as meta data for header template
        pageTitle: ({ htmlWebpackPlugin }) =>
            htmlWebpackPlugin.options.pageTitle,
        scripts: ({ manifest }) => manifest.initial,

        addon: ({ htmlWebpackPlugin }) =>
            htmlWebpackPlugin.options.svelte.addon || '',

        // Pass state to handlebars templates
        header: (state) => header(state),
        footer: (state) => footer(state),

        // Add the initial page state,
        // Allowing our app to hydrate
        pageState: (state) => {
            let opts = state.htmlWebpackPlugin.options.svelte;
            return (
                `<script>` +
                `console.log('Manifest', ${JSON.stringify(manifest)});` +
                `window.__APP_STATE__ = { ` +
                `  initialRoute: "${opts.pathname}",` +
                `  componentPath: "${opts.componentPath}"` +
                `}` +
                `<\/script>` // eslint-disable-line
            );
        },

        // Get processed svelte template and evaluate it
        // in a separate node VM (eval)
        // Allows us to avoid bundling every possible page template
        innerComponent: ({ htmlWebpackPlugin, compilation, state }) => {
            const _eval = __non_webpack_require__('eval');
            const assetName = htmlWebpackPlugin.options.svelte.internalTemplate;

            if (!assetName) {
                return '';
            }

            try {
                const asset = compilation.assets[assetName];

                const context = _eval(
                    asset.source(),
                    assetName,
                    {
                        window: undefined,
                        document: undefined,
                        fetch: undefined,
                    },
                    false /* Do not include node globals */
                );

                return context.render(state);
            } catch (e) {
                console.log(e);
                return 'error: ' + e.message;
            }
        },
    },
};
</script>
