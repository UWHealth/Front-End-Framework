{@html
    `<!DOCTYPE html>
    <html lang="en">`
}
{@html header}
{@html '<body>'}
    <div id="app" class="application">
        {@html innerComponent}
    </div>
    {@html addon}
    {@html pageState}
<!-- doctype, html, and body are strings 
    to prevent svelte from evaluating them -->
{@html '</body></html>'}

<script>
import header from '@/components/header/_header.hbs';
import footer from '@/components/footer/_footer.hbs';

export default {
    data: () => ({
        asset: null,
        compilation: '',
        htmlWebpackPlugin: {
            options: {
                render: {}
            }
        },
        manifest: {},
        noInternal: false,
        publicPath: __webpack_public_path__,
        fromServer: {}
    }),
    helpers: {

    },
    computed: {
        // Convert htmlWebpackPlugin options as meta data for header template
        pageTitle: ({ fromServer, htmlWebpackPlugin }) =>
            fromServer.pageTitle || htmlWebpackPlugin.options.pageTitle,
        // Get initial scripts from manifest, if they exist
        // (filter hot-module-replacement updates)
        scripts: ({ manifest, initialFiles }) =>
            manifest.initial &&
            manifest.initial.filter(
                (script) => script.indexOf('hot-update') < 0
            ),

        addon: ({ fromServer, htmlWebpackPlugin }) =>
            fromServer.addon || '',

        // Pass state to handlebars templates
        header: (state) => header(state),
        footer: (state) => footer(state),

        // Add the initial page state,
        // Allowing our app to hydrate
        pageState: (state) => {
            let {pathname, componentPath} = state.fromServer || state.htmlWebpackPlugin.options.render;
            return (
                `<script>` +
                `console.log('Manifest', ${JSON.stringify(state.manifest)});` +
                `var webpackPlugin = ${JSON.stringify(
                    state.htmlWebpackPlugin
                )};` +
                `window.__APP_STATE__ = { ` +
                `  initialRoute: "${pathname}",` +
                `  componentPath: "${componentPath}"` +
                `}` +
                // eslint-disable-next-line
                `<\/script>`
            );
        },

        // Get processed svelte template and evaluate it
        // in a separate node VM (eval)
        // Allows us to avoid bundling every possible page template
        innerComponent: (state) => {
            if (state.noInternal) return '';
            if (!state.asset) {
                const _eval = __non_webpack_require__('eval');

                let { htmlWebpackPlugin, compilation } = state;

                const assetName =
                    htmlWebpackPlugin.options.render.internalTemplate;

                if (!assetName) {
                    return '';
                }

                try {
                    const source = compilation.assets[assetName].toSource();
                    const context = _eval(
                        source,
                        assetName,
                        {
                            window: undefined,
                            document: undefined,
                            fetch: undefined,
                        },
                        false /* Do not include node globals */
                    );
                    return context.render(state);
                } catch (e) {
                    // eslint-disable-next-line
                    console.log(e);
                    return 'error: ' + e.message;
                }
            }
            // console.log(asset);
            return state.asset.render(state);
        },
    },
};
</script>
