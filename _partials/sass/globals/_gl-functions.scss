//------------------------------------*\
//    #Global Functions
//------------------------------------*/

// CONTENTS
// INTRODUCTION.........Explanation.
// REFERENCE............List of functions and how to use them.
// MATH.................Complex calculations and variables.
// HELPERS..............Simple functions to fix some features missing in Sass.
// TYPOGRAPHY...........Most often referenced from within type/_typography.scss.
// MODULAR SCALE........Making typographic scaling more harmonious.
// COLORS...............Calculating color differences.
// LISTS................Mixins for easier control of lists.


//------------------------------------
// $INTRODUCTION
//------------------------------------

// General functions to make Sass a little more powerful. Taken from various places.

/* SG
#Functions/General Functions [[dev]]

/globals/_gl-functions.scss

-------------------------------------------

###Math Functions

---

##### `exponent()`
###### function(`$number`, `$exponent`)
Exponentially multiply (cube, square, etc) a number.

##### `pow()`
###### function(`$number`, `$exponent`, `$precision:12`)
A more robust exponent multiplication which allows for decimal-based exponents. This replaces Compass' pow() function.

##### `gcd()`
###### function(`$number-1`, `$number-2`)
Greatest Common Divisor calculation (useful for calculating grids and widths)

##### `lcm()`
###### function(`$a`, `$b`)
Finds the least common multiple.

##### `nth_root()`
###### function(`$base`, `$n:2`, `$precision:12`)
Advanced calculation for square roots, cube roots, etc. of a value.

##### `sqrt()`
###### function(`$base`, `$precision:12`)
Find the square root of a value.

##### `golden()`
###### function(`$base: 1`)
Get the golden ratio from `$base`.

##### `sin()`
###### function(`$angle`)
Determines the Sine of an angle.

##### `cos()`
###### function(`$angle`)
Determines the Cosine of an angle.

##### `tan()`
###### function(`$angle`)
Determines the Tangent of an angle.

---

###Sass Helpers

---

##### Converter Functions #####

##### `strip-units()`
###### function(`$value`)
Remove px,em,rem, etc. from a value. Usually a variable. This is sometimes required because Sass cannot calculate incompatible (px * rem for instance) units.

##### `percentage-to-decimal()`
###### function(`$percentage`)
Changes percent value to decimal.

##### `px-to-vw()`
###### function(`$pixels`)
Converts pixel dimensions to viewport width (vw) dimensions.

##### `px-to-rems()`,`rems()`
###### function(`$pixels`, `$base-font`:`$$base-font-size`)
Function for calculating `rem` values. Used by `@rems()`. The `$base-size` is used to calculate the initial value to calculate the value (e.g. if the `body`'s `font-size` is `16px`, then the rem value of `24px` would be `1.5rem`).

##### `list-to-string()`, `str-join()`
###### function(`$list`, `$separator:","`)
Converts a list to a string with an optional separator.

##### String & List Functions #####

##### `contains()`
###### function(`$data`, `$value`)
Generic `contains` function(similar to javascript's `indexOf`). Parses a variable(`$data`) for a `$value`. Returns boolean.

##### `str-append()`
###### function(`$data`, `$separator:','`)
Adds one string to another (e.g. `str-append('hello', 'world')` becomes `hello world`). Used by `str-join()`.

##### `list-contains()`
###### function(`$list`, `$value`)
Checks whether a `$list` contains a `$value`.

##### `list-print()`
###### function(`$list`, `$depth: 1`)
Used to turn a list into a flat string. For debug purposes.


##### Map Functions #####
*[Reference](http://www.sitepoint.com/extra-map-functions-sass/)*

##### `map-deep-set()`
###### function(`$map`, `$keys...`(`$value`))
Add to a deeply nested map key. Accepts any number of keys, but the final value is the new key.

##### `map-depth()`
###### function(`$map`)
Find depth of a `$map`. Returns number.

##### `map-has-keys()`,`map-contains-keys()`
###### `[map], [key(s) to be checked ...]`
Determine whether a map contains certain keys.

##### `map-has-nested-keys()`, `map-contains-nested-keys()`
###### function(`$map`, `$keys...`)
Check for the value of a nested key. Returns boolean value.

##### `map-get-nested()`
###### function(`$map`, `$keys...`)
Returns nested map values. A deep version of Sass' `map-get()`.

##### `map-extend()`
###### function(`$map`, `$maps...`(`$deep:true`))
Merges multiple maps. Similar to jQuery's .extend().

##### `map-add-depth()`
###### function(`$map`, `$new-key:'base'`)
Adds one level to a map using the new key to a map. Used by `generate_color_varations()`. (e.g. `(key: value, key: value)` becomes `(key:(new-key: value), key:(new-key: value))` )

##### `map-print()`, `map-inspect()`
###### function(`$map`, `$level:1`)
Prints map into a string (in a JSON-esque format). Useful for debugging.

---

### Photoshop Converters  ###

---

##### `photoshop-shadow()`
###### function(`$color:#000`, `$angle:120`, `$distance:0`, `$size:0`, `$spread:0`, `$inner:false`)
Takes photoshop "Drop Shadow" layer style arguments and converts them to CSS `box-shadow` values.

##### `photoshop-text-shadow()`
###### function(`$color:#000`, `$angle:120`, `$distance:0`, `$size:0`, `$spread:null`)
Takes photoshop "Drop Shadow" layer style arguments and converts them to CSS `text-shadow` values.

##### `photoshop-gradient-overlay()`
###### function(`$gradient-colors:(#000, #fff)`, `$gradient-stops:(0%, 100%)`, `$angle:90deg`, `$opacity:100%`, `$scale:100%`, `$bg-color:white`, `$blend:normal`)
Takes photoshop "Gradient Overlay" layer style arguments and converts them to CSS `linear-gradient` values.

##### `convert-angle()`
###### function(`$angle`)
Converts Photoshop angles to CSS angles.

##### `stop-scale()`
###### `[stop], [scale]`
Converts Photoshop gradient-stops to CSS gradients.

---

### Type Functions ###

---

##### `baseline()`
###### function(`$font-size`, `$baseline`)
Aligns a font-size to a baseline. Dividing by the `$font-size` yields a unitless value (equivilent to rems).

##### `baseline-lcm()`
###### function(`$font-size`, `$line-height`)
Calculate the least-common-denominator between a font-size and a baseline.

##### `baseline-calc()`
###### function(`$font-size:``$$base-font-size`, `$font-base:``$$base-font-size`, `$calc-override: false`)
Used generating line-heights that line up to the baseline grid. Override recommended behavior with a boolean third value to gain most eye-pleasing values.

##### `modular-scale()`
###### function(`$scale`, `$ratio:``$$scale-ratio`)
Generates a pixel value that is an exponent of a ratio (defaults to $scale-ratio value). Used by `type-scale()`.

##### `get-type()`,`type()`
###### `[font-size],[font-size-value]`
function for finding the value of an indexed type-size. H1-H6, p, and small are all indexed values. px, rem, and line-height are available.

##### `define-type()`
###### `[font-size], [property], [new value]`
Registers new values to type map. [Property] accepts px, rem, and line-height.
*/


//------------------------------------
//  $MATH
//------------------------------------

// All functions taken from SassyMath:
// https://github.com/Team-Sass/Sassy-math/blob/master/sass/math.scss

//Useful variables for calculating math functions
$pi: 3.1415926535897932384626433832795028841971693993751;
$π: $pi;
$e: 2.71828182845904523536028747135266249775724709369995;

$iter: 50;

// Exponent function (for square, cubes, etc.)
@function exponent($number, $exponent) {
	// reset value
	$value: $number;
	// positive intergers get multiplied
	@if $exponent > 1 {
	@for $i from 2 through $exponent {
		$value: $value * $base; } }
	// negitive intergers get divided. A number divided by itself is 1
	@if $exponent < 1 {
		@for $i from 0 through -$exponent {
			$value: $value / $base; } }
	// return the last value written
	@return $value;
}

//More advanced exponent function — very similar to Compass' pow() function, but without the ruby dependency.
@function pow($number, $exponent, $precision: 12) {
  // Handles decimal exponents by trying to convert them into a fraction and then use a nth_root-algorithm for parts of the calculation
	$base: $number;
	$prec: $precision;

	@if floor($exponent) != $exponent {
		$prec2 : pow(10, $prec);
		$exponent: round($exponent * $prec2);
		$denominator: gcd($exponent, $prec2);
		@return nth_root(pow($base, $exponent / $denominator), $prec2 / $denominator, $prec);
	}

	$value: $base;
	@if $exponent > 1 {
		@for $i from 2 through $exponent {
			$value: $value * $base;
		}
	} @else if $exponent < 1 {
		@for $i from 0 through -$exponent {
			$value: $value / $base;
		}
	}

	@return $value;
}

//Greatest Common Divisor
@function gcd($number-1, $number-2) {
  // From: http://rosettacode.org/wiki/Greatest_common_divisor#JavaScript
	@if $number-2 != 0 {
		@return gcd($number-2, ($number-1 % $number-2));
	}@else {
		@return abs($number-1);
	}
}

//Least common Multiple
//Use with caution...if there is no LCM, then you compilation will error out.
@function lcm($a, $b) {
	$a: round($a);
	$b: round($b);
	$gcd: gcd($a, $b);
	$result: ($a * $b) / $gcd;
	@return $result;
}

//Nth Root Function
// From: http://rosettacode.org/wiki/Nth_root#JavaScript
@function nth_root($base, $n: 2, $precision: 12) {
	$prec: $precision;
	$x: 1;

	@for $i from 0 through $prec {
		$x: 1 / $n * (($n - 1) * $x + ($base / pow($x, $n - 1)));
	}

	@return $x;
}

//Square Root functions
@function sqrt($base, $precision: 12) {
	$guess: random(20);
	$root: $guess;

	@for $i from 1 through $precision {
		$root: $root - (pow($root, 2) - $base) / (2 * $root);
	}
	@return $root;
}

//Golden Ratio generator.
@function golden($base: 1) {

	@return (1/2 + sqrt(5) / 2) * $base;
}

$golden_ratio: golden();

//Sine
// From: https://unindented.org/articles/trigonometry-in-sass/
@function sin($angle) {
	$sin: 0;
	$angle: rad($angle);
	// Iterate a bunch of times.
	@for $i from 0 through 10 {
		$sin: $sin + pow(-1, $i) * pow($angle, (2 * $i + 1)) / fact(2 * $i + 1);
	}
	@return $sin;
}

//Cosine
@function cos($angle) {
	$cos: 0;
	$angle: rad($angle);
	// Iterate a bunch of times.
	@for $i from 0 through 10 {
		$cos: $cos + pow(-1, $i) * pow($angle, 2 * $i) / fact(2 * $i);
	}
	@return $cos;
}

//Tangent
@function tan($angle) {
	@return sin($angle) / cos($angle);
}

// Math helpers
// From https://github.com/inuitcss/tools.functions/blob/master/_tools.functions.scss
//
// Halve and double numbers, returning rounded integers. E.g.:
//
// .foo {
//     padding: halve(3.2px);
// }
//
// Outputs:
// .foo{padding: 2px;}
//
@function quarter($number) {
	@return round($number / 4);
}

@function halve($number) {
	@return round($number / 2);
}

@function double($number) {
	@return round($number * 2);
}

@function quadruple($number) {
	@return round($number * 4);
}

//------------------------------------
//    $HELPERS
//------------------------------------

// Strip units from a sass value
// Taken from:
// http://stackoverflow.com/questions/12328259/how-do-you-strip-the-unit-from-any-number-in-sass
@function strip-units($value) {
	@return $value / ($value * 0 + 1);
}

// Percent to Decimal
//
@function percentage-to-decimal($percentage) {
	@if unit($percentage) == '%' {
		$percentage: $percentage/100%;
	}
	@return $percentage;
}

//Viewport width from pixel converter
// Converts pixel dimensions to viewport
@function px-to-vw($pixels) {
	$vw-context: (1000*.01) * 1px;
	@return ($pixels/$vw-context) * 1vw;
}

//Stripped REM generator
//Useful if you just need the rem value
@function px-to-rems($pixels, $base-size:$base-font-size) {
	@if (unitless($pixels)){
		$pixels: $pixels * 1px;
	}

	$pixels: ($pixels / $base-size) * 1rem;

	@if $pixels == 0rem {
		$pixels: 0;
	}

	@return $pixels;

}

//ALIAS: Same as above
@function rems($pixels, $base-size:$base-font-size) {
	@return px-to-rems($pixels, $base-size);
}

//List Join
//Convert a list to a string
@function list-to-string($list, $separator: ",") {
	$string: "";

	@for $i from 1 through length($list) {
		$string: str-append($string, #{nth($list, $i)});

		@if $i != length($list) {
			$string: str-append($string, $separator);
		}
	}

	@return $string;
}

//String Helpers
//-----------------------------------
// Taken from: https://github.com/devatrox/Sunglass

//General 'contains' checker
// Delegates methods to the appropriate function based on variable type
@function contains($data, $value){
	@if type-of($data == "map"){
		@return map-has-keys($data, $value);
	}@else if type-of($data == "list"){
		@return list-contains($data, $value);
	}@else if type-of($data == "string"){
		@return str-contains($data, $value);
	}
}

//String Join
// Converts list to a string with an optional separator
@function str-join($list, $separator: ",") {
	@return list-to-string($list, $separator);
}

// String contains check
// Outputs true/false based on inputs
@function str-contains($string, $value, $pos: 0) {

	$string: str-slice($string, $pos);

	@if str-index($string, $value) != null {
		@return true;
	}
	@else {
		@return false;
	}
}

//String Append
// Adds string to end of another string
@function str-append($string, $insert) {
	$string: if($string == null, "", $string);

	@return str-insert($string, $insert, str-length($string) + 1);
}

// List contains check
// Outputs true/false
@function list-contains($list, $value) {
	@return not not index($list, $value);
}

//Reverse a List
@function list-reverse($list, $recursive: false) {
   $result: ();

   @for $i from length($list)*-1 through -1 {
		@if type-of(nth($list, abs($i))) == list and $recursive {
			$result: append($result, reverse(nth($list, abs($i)), $recursive));
		}
		@else {
			$result: append($result, nth($list, abs($i)));
		}
	}

	@return $result;
}

//List print
@function list-print($list, $depth:1) {
	$output: '';

	@if $depth > 0 {
		@for $i from 1 through $depth {
			$output: $output + $list;
		}
	}

	@return $output;
}


//Map Helpers
//-----------------------------------
//Taken from: http://www.sitepoint.com/extra-map-functions-sass/

//Deep Set
//Update a deeply nested map key.
@function map-deep-set($map, $keys... /*, $value */) {
	$map-list: ($map,);
	$result: null;

	@if length($keys) == 2 {
		@return map-merge($map, (nth($keys, 1): nth($keys, -1)));
	}

	@for $i from 1 through length($keys) - 2 {
		$map-list: append($map-list, map-get(nth($map-list, -1), nth($keys, $i)));
	}

	@for $i from length($map-list) through 1 {
		$result: map-merge(nth($map-list, $i), (nth($keys, $i): if($i == length($map-list), nth($keys, -1), $result)));
	}

	@return $result;
}

//Map depth finder
// Returns a map's depth. Useful for debugging maps.
@function map-depth($map) {
	$level: 1;

	@each $key, $value in $map {
		@if type-of($value) == "map" {
			$level: max(map-depth($value) + 1, $level);
		}
	}

	@return $level;
}

//Check multiple map keys
@function map-has-keys($map, $keys...) {
	@each $key in $keys {
		@if not map-has-key($map, $key) {
			@return false;
		}
	}

	@return true;
}

@function map-contains-keys($map, $keys...){
	@return map-has-keys($map, $keys);
}

//Check for deep map keys
@function map-has-nested-keys($map, $keys...) {
	@each $key in $keys {
		@if not map-has-key($map, $key) {
			@return false;
		}

		$map: map-get($map, $key);
	}

	@return true;
}
//ALIAS
@function map-contains-nested-keys($map, $keys...) {
	@return map-has-nested-keys($map, $keys);
}

//Get map value at nested or 'deep' key, per $keys list
@function map-get-nested($map, $keys...) {
	@each $key in $keys {
		@if type-of($map) != 'map' {
			@return $map;
		}
		$map: map-get($map, $key);
	}
	@return $map;
}

//Map Extend
// Similar to jQuery's extend function but for sass maps
// Takes two maps and merges their differences
@function map-extend($map, $maps... /*, $deep */) {
	$last: nth($maps, -1);
	$deep: $last == true;
	$max: if($deep, length($maps) - 1, length($maps));

	// Loop through all maps in $maps...
	@for $i from 1 through $max {
		// Store current map
		$current: nth($maps, $i);

		// If not in deep mode, simply merge current map with map
		@if not $deep {
			$map: map-merge($map, $current);
		} @else {
			// If in deep mode, loop through all tuples in current map
			@each $key, $value in $current {

				// If value is a nested map and same key from map is a nested map as well
				@if type-of($value) == "map" and type-of(map-get($map, $key)) == "map" {
					// Recursive extend
					$value: map-extend(map-get($map, $key), $value, true);
				}

				// Merge current tuple with map
				$map: map-merge($map, ($key: $value));
			}
		}
	}

	@return $map;
}


//Map depth-adder
//-------------------------
// Adds 'base'(or whatever initial key that's passed in) to a color map.
// Used by color map generator function (colors/_colorfunctions)
//--------------------------
// 1. Check if map is less than or equal to the depth tolerance (default: 1).
// 2. loops through all keys and values in the map.
// 3. Make sure value isn't alreayd a map
//   3a. If value is a map, then check to make sure $new-key is in the map
//     3b. Duplicate first value of map (in case there are multiple)
//     3c. Create new map with new-key and duplicated value
// 4. Reformats those key-value pairs into a (key: (new-key: value ))
// 5. Merges new depthy key-key-value back into the map.
// 6. Returns the new map.

@function map-add-depth($map, $new-key: base){
	$formatted-key:(); $new-map:'';

	@each $key, $value in $map { 				//[2]
		$formatted-key: ();
		@if type-of($value) != "map" {                      //[3]
			$formatted-key: ($key: ($new-key: $value));     //[4]

		}@else if not map-has-key($value, $new-key) {       //[3a]
			$duplicate-value: map-get($value, nth(map-keys($value), 1)); //[3b]
			$duplicate-map: ($new-key : $duplicate-value);               //[3c]

			$formatted-key: ($key: (map-merge($value, $duplicate-map))); //[4]
		}
		$map: map-merge($map, $formatted-key);		//[5]
	}

	@return $map; 									//[6]
}

//Map printer
//Print maps into a string
// Useful for debugging maps.
// Taken from: https://github.com/lunelson/sass-maps-plus

@function map-inspect($map, $level: 1) {
	$tab: '    ';
	$cr: '
';

	@if type-of($map) != 'map' {
		@return '#{inspect($map)}';
	}

	$indent: list-print($tab, $level + 1);
	$output: '{' + $cr + $indent; $i: 1;

	@each $key, $value in $map {
		@if type-of($value) == 'map' {
			$output: $output + '#{$key}: #{map-inspect($value, $level+1)}';
		} @else {
			$output: $output + '#{$key}: #{$value}';
		}

		@if $i < length(map-keys($map)) {
			$output: $output + ',' + $cr + $indent;
		}

		$i: $i + 1;
	}

	$outdent: list-print($tab, $level);

	@return $output + $cr + $outdent + '}';
}
//ALIAS
@function map-print($map, $level: 1){
	@return map-inspect($map, $level);
}


//-----------------------------------
//    $PHOTOSHOP LAYER STYLE MIMICS
//-----------------------------------

//Photoshop shadow mimic
// Allows you to use photoshop drop/inner shadow settings to generate CSS shadows

@function photoshop-shadow (
	$color: #000,
	$angle: 120,
	$distance: 0,
	$size: 0,
	$spread: 0,
	$inner: false
) {

	$x-offset: round( cos( $angle ) * $distance );
	$y-offset: round( sin( $angle ) * $distance );
	$css-spread: $size * ( $spread/100 );
	$blur: $size - $css-spread;
	$inset: if( $inner != false, 'inset', '' );

	@return ( $x-offset $y-offset $blur $css-spread $color unquote($inset) );
}

//Photoshop text-shadow converter
// Same as above, but for text-shadows
@function photoshop-text-shadow (
	$color: #000,
	$angle: 120deg,
	$distance: 0,
	$size: 0,
	$spread: null
) {

	@if $spread != null {
		@warn "spread has no effect for text shadows";
	}

	$shadow: photoshop-shadow( $color, $angle, $distance, $size, $spread);

	@return ( nth( $shadow, 1 ) nth( $shadow, 2 ) nth( $shadow, 3 ) nth( $shadow, 5 ) );
}

//Photoshop gradient overlay converter

@function photoshop-gradient-overlay(
	$gradient-colors: (#000, #fff),
	$gradient-stops: (0%, 100%),
	$angle: 90deg,
	$opacity: 100%,
	$scale: 100%,
	$bg-color: white,
	$blend: normal
) {
	$gradient-stops: (0%, 100%) !default;
	$css-angle: convert-angle($angle);
	$color-stops: ();

	@for $i from 1 through length($gradient-colors) {
		$blended-color: blend($blend, nth($gradient-colors, $i), $bg-color);
		$stop: join($blended-color, stop-scale(nth($gradient-stops, $i), $scale), space);
		$color-stops: append($color-stops, $stop, comma);
	}
	@return linear-gradient($css-angle, $color-stops);
}

//Convert angles for css gradients
@function convert-angle($angle) {

	@if $angle == 0 or $angle == 360 {
		@return left;
	} @else if $angle == 45 or $angle == -315 {
		@return left bottom;
	} @else if $angle == 90 or $angle == -270 {
		@return bottom;
	} @else if $angle == 135 or $angle == -225{
		@return right bottom;
	} @else if $angle == 180 or $angle == 180{
		@return right;
	} @else if $angle == -135 or $angle == 225 {
		@return right top;
	} @else if $angle == -90 or $angle == 270 {
		@return top;
	} @else if $angle == -45 or $angle == 315 {
		@return left top;
	} @else {
		@return $angle - 90deg;
	}
}

//Photoshop gradient stop converter
// Used in gradient overlay function
@function stop-scale($stop, $scale) {
	$stop: percentage-to-decimal($stop);
	$new-stop: 0;
	$scale: percentage-to-decimal($scale);

	@return percentage($scale * $stop - (0.5 * ($scale - 1)));
}

//------------------------------------
//    $TYPOGRAPHY
//------------------------------------

//Baseline function. Converts to floated integer.
@function baseline($font-size, $baseline, $i:1){
	@return ceil($font-size / ($baseline*$i)) * ($baseline*$i) / $font-size;
}

@function check-base-line($magic-number, $i:1) {
	$ratio: $magic-number / $base-font-size;

	@while $ratio < 1.1 {
		$magic-number: ceil($base-font-size / ($base-line-height * $i)) * ($base-line-height * $i);
		$ratio: ($magic-number / $base-font-size);
		$i: $i + 1;

    }

	@return $magic-number;
}

//Calculate the least-common-denominator between a font-size and a baseline.
@function baseline-lcm($font-size, $line-height){
	$esl: $line-height * $font-size;
	@return lcm( $esl, $base-line-height );
}

// Calculate the baseline of any particular font-size.
@function baseline-calc(
	$font-size: $base-font-size,
	$font-base: $base-font-size,
	$calc-override: false
){
	//Easiest measurement of font-size deviation
	$font-ratio: 1.1;
	$upper-bound: 1.9;
	$lower-bound: 1.1;

	@if ($font-size > $base-font-size){
		$font-ratio: round(($font-size/1px) % ($base-font-size/1px));
	}@else{
		$font-ratio: round(($base-font-size/1px) % ($font-size/1px));
	}

	@while $font-ratio > 1 {
		$font-ratio: $font-ratio * 0.1;
	}

	@if $font-ratio < 1 {
		$font-ratio: $font-ratio + 1;
	}

	$line-height: baseline($font-size, $base-line-height);
	//$inc-dec: if($base-line-height <= $base-font-size, unquote('/'), unquote("*"));
	$i: 1;
	@debug "ratio: #{$font-ratio}, size: #{$font-size}";

	@while $line-height <= 1.1 and $line-height < 1.9 {

		$line-height: baseline($font-size, ($base-line-height / 2), $i);

		@if $i > (($font-ratio * 10) - 10) and ($font-ratio % 1) != 0 {
			$line-height: baseline($font-size, $base-line-height, $font-ratio);
		}

		//@debug ($font-ratio % 1);

		$i: $i + 1;

		@if $i > 10 {
			$line-height: $type-magic-ratio;
		}
	}
	@debug $line-height * $font-size;
	@return $line-height;

	////baseline
	//$bl: $type-magic-ratio * $font-base;
	////Every other line.
	//$baseline-odd: $type-magic-number / 2;
	////Every third line.
	//$baseline-odder: $base-line-height / 1.33333;
	//$baseline-cache: $bl;
	//
	//// Using half-baseline grid for first calculation.
	//// This is helpful for smaller font-sizes
	//// and gives more leeway with larger ones.
	//
	//$baseline: baseline($font-size, $baseline-odd);
	////If this produces either too small or large a line-height,
	//// then let's make some corrections.
	//// This will only work on fonts larger than the base-font-size unless
	//// $calc-override is set to true.
	//@debug "font: #{$font-size}, line: #{$baseline}";
	//
	//@if $font-size >= $font-base or $calc-override == true {
	//
	//	//First we can try using every third line.
	//	@if $baseline > 1.8 or $baseline <= 1.2{
	//			$baseline-cache: $baseline;
	//			$baseline: baseline($font-size, $baseline-odder);
	//	}
	//	@if $baseline < 1.1 or $baseline > 1.9 {
	//
	//		//If that's not working, let's see if
	//		// our original value is better by loosening our tolerance.
	//		@if $baseline-cache > 1.1 and $baseline-cache < 1.9{
	//			$baseline: $baseline-cache;
	//		}@else{
	//			//If both options are bad, then let's use the standard baseline.
	//			$baseline: baseline($font-size, $base-line-height);
	//		}
	//	}
	//}
	//@return $baseline;
}

//Generates a number based on the typographic grid
@function type-space($multiplier: 2){
	@return $multiplier * $type-magic-number;
}

//------------------------------------
//    $MODULAR SCALE
//------------------------------------

// Modular scale function to scale type up or down.
@function modular-scale($scale, $ratio: $scale-ratio){
	$modular-scale: $ratio;

	@if length($ratio) == 2 {
	// Making sure we don't have a ratio below 1.
	    @if nth($ratio,1) < nth($ratio,2){
	        $modular-scale:   nth($ratio, 2)/nth($ratio, 1);
	    }@else{
	        $modular-scale:   nth($ratio, 1)/nth($ratio, 2);
	    }
	}

	$font-size:  strip-units($base-font-size);
	@return pow($modular-scale, $scale)*($font-size) * 1px;
}

//Get the property of a particular font. e.g.:
// h1{
//    font-size: type(h2, px)
// }
// Would return the pixel value of the h2 font-size.
@function get-type($font-size, $property: 'px'){
	@if $property == 'font-size'{
		$property: 'px';
	}
	@return map-get(map-get($type, $font-size), $property);
}
//ALIAS: shorter name (possibly more confusing)
@function type($font-size, $property: 'px') {
	@return get-type($font-size, $property);
}

//Internal function used for definining the type map.
@function define-type($font-size, $property: 'px', $new-value: "") {
	$target_font: map-get($type, $font-size);
	$target-w-property: map-merge($target_font, ($property : $new-value));
	@return map-merge($type, ($font-size:$target-w-property));
}
