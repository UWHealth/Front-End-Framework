// CONTENTS
// INTRODUCTION.........Explanation.
// REFERENCE............List of functions and how to use them.
// MATH.................Complex calculations and variables.
// HELPERS..............Simple functions to fix some features missing in Sass.
// TYPOGRAPHY...........Most often referenced from within type/_typography.scss.
// MODULAR SCALE........Making typographic scaling more harmonious.
// COLORS...............Calculating color differences.
// LISTS................Mixins for easier control of lists.


//------------------------------------
// $INTRODUCTION
//------------------------------------

// General functions to make Sass a little more powerful. Taken from various places.

/* SG
#[[dev]]Globals/Functions

---

###Math Functions

---

##### `exponent()`
###### `[number-you-want-to-multiply]`, `[exponent]`
Exponentially multiply (cube, square, etc) a number.

##### `pow()`
###### `[number-you-want-to-multiply]`, `[exponent]`
A more robust exponent multiplication which allows for decimal-based exponents. This replaces Compass' pow() function.

##### `gcd()`
###### `[first-number], [second-number]`
Greatest Common Divisor calculation (useful for calculating grids and widths)

##### `lcm()`
###### `[first-number], [second-number]`
Finds the least common multiple.

##### `nth_root()`
###### `[number-you-want-to-find-the-root-of], [root-divisor]`
Advanced calculation for square roots, cube roots, etc. of a value.

##### `sqrt()`
###### `[number-you-want-the-square-root-of]`
Find the square root of a value.

##### `golden()`
Generate the golden ratio. Useful for multiplication and division.

##### `sin()`
###### `[angle]`
Determines the Sine of an angle.

##### `cos()`
###### `[angle]`
Determines the Cosine of an angle.

##### `tan()`
###### `[angle]`
Determines the Tangent of an angle.

---

###Sass Helpers

---

#### Converter Functions ####

##### `strip-units()`
###### `[value-you-want-units-removed-from]`
Remove px,em,rem, etc. from a value. Usually a variable.

##### `percentage-to-decimal()`
###### `[percent]`
Changes percent value to decimal.

##### `px-to-vw()`
###### `[pixel value]`
Converts pixel dimensions to viewport width (vw) dimensions.

##### `px-to-rems()`,`rems()`
###### `[pixel-value-you-need-converted], [base-font-size-override]`
Function for calculating stripped-unit REM values. Used by rems() mixin. Override base font size for media-queries where the breakpoint has a smaller/larger base-font.

##### `list-to-string()`, `str-join()`
###### `[list-you-need-converted], [list-seperator]`
Converts a list to a string with an optional separator.

#### String & List Functions ####

##### `str-contains()`
###### `[string-you-need-parsed],[sub-string], [start-position]`
Parses a string for a value (from an optional starting position).

##### `str-append()`
###### `[string], [string-to-append]`
Adds one string to another (e.g. `str-append('hello', 'world')` becomes `hello world`). Used by str-join.

##### `list-contains()`
###### `[list], [value]`
Checks whether a list contains a value.

##### `list-print()`
###### `[list]`
Used to turn a list into a flat string. For debug purposes.


#### Map Functions ####
*Reference: http://www.sitepoint.com/extra-map-functions-sass/*

##### `map-deep-set()`
###### `[map], [keys to be updated ...], [new value]`
Add to a deeply nested map key. Accepts any number of keys, but the final value is the new key.

##### `map-depth()`
###### `[map]`
Find depth of a map. Returns number.

##### `map-has-keys()`,`map-contains-keys()`
###### `[map], [key(s) to be checked ...]`
Determine whether a map contains certain keys.

##### `map-has-nested-keys()`, `map-contains-nested-keys()`
###### `[map], [key(s) to be checked...] `
Check for the value of a nested key. Returns boolean value.

##### `map-get-nested()`
###### `[map], [key(s) to find value... ]`
Returns nested map values. A deep version of Sass' `map-get()`.

##### `map-extend()`
###### `[map], [map(s) to merge ... ], [deep?]`
Merges multiple maps. Similar to jQuery's .extend().

##### `map-add-depth()`
###### `[map], [new key]`
Adds one level to a map using the new key to a map. Used by color map generator function (colors/\_colorfunctions). (e.g. `(key: value, key: value)` becomes `(key:(new-key: value), key:(new-key: value))` )

##### `map-inspect()`
###### `[map], [starting indent level]`
Prints map into a string. Useful for debugging.

---

### Photoshop Converters  ###

---

##### `photoshop-shadow()`, `photoshop-text-shadow()`, `photoshop-gradient-overlay()`
###### `[various]`
MIXINs: Interprets Photoshop layer styles as they'd appear in Photoshop into CSS. See functions for their accepted arguments.

##### `convert-angle()`
###### `[angle]`
Converts Photoshop angles to CSS angles.

##### `stop-scale()`
###### `[stop], [scale]`
Converts Photoshop gradient-stops to CSS gradients.

---

### Type Functions ###

---

##### `baseline()`
###### `[font-size]`, `[baseline]`
Aligns a font-size to a baseline. Dividing by the $font-size yields a unitless-REM value.

##### `baseline-lcm()`
###### `[font-size]`, `[line-height]`
Calculate the least-common-denominator between a font-size and a baseline.

##### `baseline-calc()`
###### `[font-size-in-pixels]`, `[base-font-size]`,`[override?]`
Used generating line-heights that line up to the baseline grid. Override recommended behavior with a boolean third value to gain most eye-pleasing values.

##### `modular-scale()`
###### `[number-on-the-scale-you-want],[ratio-to-use-as-scale]`
Generates a pixel value that is an exponent of a ratio (defaults to $scale-ratio value). Used by `type-scale()`.

##### `get-type()`,`type()`
###### `[font-size],[font-size-value]`
function for finding the value of an indexed type-size. H1-H6, p, and small are all indexed values. px, rem, and line-height are available.

##### `define-type()`
###### `[font-size], [property], [new value]`
Registers new values to type map. [Property] accepts px, rem, and line-height.
*/


//------------------------------------
//  $MATH
//------------------------------------

// All functions taken from SassyMath:
// https://github.com/Team-Sass/Sassy-math/blob/master/sass/math.scss

//Useful variables for calculating math functions
$pi: 3.1415926535897932384626433832795028841971693993751;
$π: $pi;
$e: 2.71828182845904523536028747135266249775724709369995;

$iter: 50;

// Exponent function (for square, cubes, etc.)
@function exponent($number, $exponent) {
	// reset value
	$value: $number;
	// positive intergers get multiplied
	@if $exponent > 1 {
	@for $i from 2 through $exponent {
		$value: $value * $base; } }
	// negitive intergers get divided. A number divided by itself is 1
	@if $exponent < 1 {
		@for $i from 0 through -$exponent {
			$value: $value / $base; } }
	// return the last value written
	@return $value;
}

//More advanced exponent function — very similar to Compass' pow() function, but without the ruby dependency.
@function pow($number, $exponent, $precision: 12) {
  // Handles decimal exponents by trying to convert them into a fraction and then use a nth_root-algorithm for parts of the calculation
	$base: $number;
	$prec: $precision;

	@if floor($exponent) != $exponent {
		$prec2 : pow(10, $prec);
		$exponent: round($exponent * $prec2);
		$denominator: gcd($exponent, $prec2);
		@return nth_root(pow($base, $exponent / $denominator), $prec2 / $denominator, $prec);
	}

	$value: $base;
	@if $exponent > 1 {
		@for $i from 2 through $exponent {
			$value: $value * $base;
		}
	} @else if $exponent < 1 {
		@for $i from 0 through -$exponent {
			$value: $value / $base;
		}
	}

	@return $value;
}

//Greatest Common Divisor
@function gcd($a, $b) {
  // From: http://rosettacode.org/wiki/Greatest_common_divisor#JavaScript
	@if $b != 0 {
		@return gcd($b, ($a % $b));
	}@else {
		@return abs($a);
	}
}

//Least common Multiple
//Use with caution...if there is no LCM, then you compilation will error out.
@function lcm($a, $b) {
	$a: round($a);
	$b: round($b);
	$gcd: gcd($a, $b);
	$result: ($a * $b) / $gcd;
	@return $result;
}

//Nth Root Function
// From: http://rosettacode.org/wiki/Nth_root#JavaScript
@function nth_root($base, $n: 2, $precision: 12) {
	$prec: $precision;
	$x: 1;

	@for $i from 0 through $prec {
		$x: 1 / $n * (($n - 1) * $x + ($base / pow($x, $n - 1)));
	}

	@return $x;
}

//Square Root functions
@function sqrt($base, $precision: 12) {
	$guess: random(20);
	$root: $guess;

	@for $i from 1 through $precision {
		$root: $root - (pow($root, 2) - $base) / (2 * $root);
	}
	@return $root;
}

//Golden Ratio generator.
@function golden($base: 1) {

	@return (1/2 + sqrt(5) / 2) * $base;
}

$golden_ratio: golden();

//Sine
// From: https://unindented.org/articles/trigonometry-in-sass/
@function sin($angle) {
	$sin: 0;
	$angle: rad($angle);
	// Iterate a bunch of times.
	@for $i from 0 through 10 {
		$sin: $sin + pow(-1, $i) * pow($angle, (2 * $i + 1)) / fact(2 * $i + 1);
	}
	@return $sin;
}

//Cosine
@function cos($angle) {
	$cos: 0;
	$angle: rad($angle);
	// Iterate a bunch of times.
	@for $i from 0 through 10 {
		$cos: $cos + pow(-1, $i) * pow($angle, 2 * $i) / fact(2 * $i);
	}
	@return $cos;
}

//Tangent
@function tan($angle) {
	@return sin($angle) / cos($angle);
}

// Math helpers
// From https://github.com/inuitcss/tools.functions/blob/master/_tools.functions.scss
//
// Halve and double numbers, returning rounded integers. E.g.:
//
// .foo {
//     padding: halve(3.2px);
// }
//
// Outputs:
// .foo{padding: 2px;}
//
@function quarter($number) {
	@return round($number / 4);
}

@function halve($number) {
	@return round($number / 2);
}

@function double($number) {
	@return round($number * 2);
}

@function quadruple($number) {
	@return round($number * 4);
}

//------------------------------------
//    $HELPERS
//------------------------------------

// Strip units from a sass value
// Taken from:
// http://stackoverflow.com/questions/12328259/how-do-you-strip-the-unit-from-any-number-in-sass
@function strip-units($value) {
	@return $value / ($value * 0 + 1);
}

// Percent to Decimal
//
@function percentage-to-decimal($percentage) {
	@if unit($percentage) == '%' {
		$percentage: $percentage/100%;
	}
	@return $percentage;
}

//General 'contains' checker
// Delegates methods to the appropriate function based on variable type
@function contains($var, $value){
	@if type-of($var == "map"){
		@return map-has-keys($var, $value);
	}@else if type-of($var == "list"){
		@return list-contains($var, $value);
	}@else if type-of($var == "string"){
		@return str-contains($var, $value);
	}
}

//Viewport width from pixel converter
// Converts pixel dimensions to viewport
@function px-to-vw($pixel-val) {
	$vw-context: (1000*.01) * 1px;
	@return ($pixel-val/$vw-context) * 1vw;
}

//Stripped REM generator
//Useful if you just need the rem value
@function px-to-rems($size, $base-font:$base-font-size) {
	@if (unitless($size)){
		$size: $size * 1px;
	}

	$size: ($size / $base-font) * 1rem;

	@if $size == 0rem {
		$size: 0;
	}

	@return $size;

}

//ALIAS: Same as above
@function rems($size, $base-font:$base-font-size) {
	@return px-to-rems($size, $base-font);
}

//List Join
//Convert a list to a string
@function list-to-string($list, $separator: ",") {
	$string: "";

	@for $i from 1 through length($list) {
		$string: str-append($string, #{nth($list, $i)});

		@if $i != length($list) {
			$string: str-append($string, $separator);
		}
	}

	@return $string;
}

//String Helpers
//-----------------------------------
// Taken from: https://github.com/devatrox/Sunglass

//String Join
// Converts list to a string with an optional separator
@function str-join($list, $separator: ",") {
	@return list-to-string($list, $separator);
}

// String contains check
// Outputs true/false based on inputs
@function str-contains($string, $substr, $pos: 0) {

	$string: str-slice($string, $pos);

	@if str-index($string, $substr) != null {
		@return true;
	}
	@else {
		@return false;
	}
}

//String Append
// Adds string to end of another string
@function str-append($string, $insert) {
  $string: if($string == null, "", $string);

  @return str-insert($string, $insert, str-length($string) + 1);
}

// List contains check
// Outputs true/false
@function list-contains($list, $var) {
	@return index($list, $item) != null;
}

//Reverse a List
@function list-reverse($list, $recursive: false) {
   $result: ();

   @for $i from length($list)*-1 through -1 {
      @if type-of(nth($list, abs($i))) == list and $recursive {
        $result: append($result, reverse(nth($list, abs($i)), $recursive));
      }

      @else {
        $result: append($result, nth($list, abs($i)));
      }
   }

   @return $result;
}

//List print
@function list-print($list, $depth:1) {
	$output: '';

	@if $n > 0 {
		@for $i from 1 through $depth {
			$output: $output + $list;
		}
	}

	@return $output;
}


//Map Helpers
//-----------------------------------
//Taken from: http://www.sitepoint.com/extra-map-functions-sass/

//Deep Set
//Update a deeply nested map key.
@function map-deep-set($map, $keys... /*, $value */) {
	$map-list: ($map,);
	$result: null;

	@if length($keys) == 2 {
		@return map-merge($map, (nth($keys, 1): nth($keys, -1)));
	}

	@for $i from 1 through length($keys) - 2 {
		$map-list: append($map-list, map-get(nth($map-list, -1), nth($keys, $i)));
	}

	@for $i from length($map-list) through 1 {
		$result: map-merge(nth($map-list, $i), (nth($keys, $i): if($i == length($map-list), nth($keys, -1), $result)));
	}

	@return $result;
}

//Map depth finder
// Returns a map's depth. Useful for debugging maps.
@function map-depth($map) {
	$level: 1;

	@each $key, $value in $map {
		@if type-of($value) == "map" {
			$level: max(map-depth($value) + 1, $level);
		}
	}

	@return $level;
}

//Check multiple map keys
@function map-has-keys($map, $keys...) {
	@each $key in $keys {
		@if not map-has-key($map, $key) {
			@return false;
		}
	}

	@return true;
}

@function map-contains-keys($map, $keys...){
	@return map-has-keys($map, $keys);
}

//Check for deep map keys
@function map-has-nested-keys($map, $keys...) {
	@each $key in $keys {
		@if not map-has-key($map, $key) {
			@return false;
		}

		$map: map-get($map, $key);
	}

	@return true;
}
@function map-contains-nested-keys($map, $keys...) {
	@return map-has-nested-keys($map, $keys);
}

//Get map value at nested or 'deep' key, per $keys list
@function map-get-nested($map, $keys...) {
	@each $key in $keys {
		@if type-of($map) != 'map' {
			@return $map;
		}
		$map: map-get($map, $key);
	}
	@return $map;
}

//Map Extend
// Similar to jQuery's extend function but for sass maps
// Takes two maps and merges their differences
@function map-extend($map, $maps... /*, $deep */) {
	$last: nth($maps, -1);
	$deep: $last == true;
	$max: if($deep, length($maps) - 1, length($maps));

	// Loop through all maps in $maps...
	@for $i from 1 through $max {
		// Store current map
		$current: nth($maps, $i);

		// If not in deep mode, simply merge current map with map
		@if not $deep {
			$map: map-merge($map, $current);
		} @else {
			// If in deep mode, loop through all tuples in current map
			@each $key, $value in $current {

				// If value is a nested map and same key from map is a nested map as well
				@if type-of($value) == "map" and type-of(map-get($map, $key)) == "map" {
					// Recursive extend
					$value: map-extend(map-get($map, $key), $value, true);
				}

				// Merge current tuple with map
				$map: map-merge($map, ($key: $value));
			}
		}
	}

	@return $map;
}


//Map depth-adder
//-------------------------
// Adds 'base'(or whatever initial key that's passed in) to a color map.
// Used by color map generator function (colors/_colorfunctions)
//--------------------------
// 1. Check if map is less than or equal to the depth tolerance (default: 1).
// 2. loops through all keys and values in the map.
// 3. Make sure value isn't alreayd a map
//   3a. If value is a map, then check to make sure $new-key is in the map
//     3b. Duplicate first value of map (in case there are multiple)
//     3c. Create new map with new-key and duplicated value
// 4. Reformats those key-value pairs into a (key: (new-key: value ))
// 5. Merges new depthy key-key-value back into the map.
// 6. Returns the new map.

@function map-add-depth($map, $new-key: base){
	$formatted-key:(); $new-map:'';

	@each $key, $value in $map { 				//[2]
		$formatted-key: ();
		@if type-of($value) != "map" {                      //[3]
			$formatted-key: ($key: ($new-key: $value));     //[4]

		}@else if not map-has-key($value, $new-key) {       //[3a]
			$duplicate-value: map-get($value, nth(map-keys($value), 1)); //[3b]
			$duplicate-map: ($new-key : $duplicate-value);               //[3c]

			$formatted-key: ($key: (map-merge($value, $duplicate-map))); //[4]
		}
		$map: map-merge($map, $formatted-key);		//[5]
	}

	@return $map; 									//[6]
}

//Map printer
//Print maps into a string
// Useful for debugging maps.
// Taken from: https://github.com/lunelson/sass-maps-plus

@function map-inspect($map, $level: 1) {
	$tab: '    ';
	$cr: '
';

	@if type-of($map) != 'map' {
		@return '#{inspect($map)}';
	}

	$indent: list-print($tab, $level + 1);
	$output: '{' + $cr + $indent; $i: 1;

	@each $key, $value in $map {
		@if type-of($value) == 'map' {
			$output: $output + '#{$key}: #{map-inspect($value, $level+1)}';
		} @else {
			$output: $output + '#{$key}: #{$value}';
		}

		@if $i < length(map-keys($map)) {
			$output: $output + ',' + $cr + $indent;
		}

		$i: $i + 1;
	}

	$outdent: list-print($tab, $level);

	@return $output + $cr + $outdent + '}';
}


//-----------------------------------
//    $PHOTOSHOP LAYER STYLE MIMICS
//-----------------------------------

//Photoshop shadow mimic
// Allows you to use photoshop drop/inner shadow settings to generate CSS shadows

@function photoshop-shadow (
	$color: #000,
	$angle: 120,
	$distance: 0,
	$size: 0,
	$spread: 0,
	$inner: false
) {

	$x-offset: round( cos( $angle ) * $distance );
	$y-offset: round( sin( $angle ) * $distance );
	$css-spread: $size * ( $spread/100 );
	$blur: $size - $css-spread;
	$inset: if( $inner != false, 'inset', '' );

	@return ( $x-offset $y-offset $blur $css-spread $color unquote($inset) );
}

//Photoshop text-shadow converter
// Same as above, but for text-shadows
@function photoshop-text-shadow (
	$color: #000,
	$angle: 120deg,
	$distance: 0,
	$size: 0,
	$spread: null
) {

	@if $spread != null {
		@warn "spread has no effect for text shadows";
	}

	$shadow: photoshop-shadow( $color, $angle, $distance, $size, $spread);

	@return ( nth( $shadow, 1 ) nth( $shadow, 2 ) nth( $shadow, 3 ) nth( $shadow, 5 ) );
}

//Photoshop gradient overlay converter

@function photoshop-gradient-overlay(
	$gradient-colors: (#000, #fff),
	$gradient-stops: (0%, 100%),
	$angle: 90deg,
	$opacity: 100%,
	$scale: 100%,
	$bg-color: white,
	$blend: normal
) {
	$gradient-stops: (0%, 100%) !default;
	$css-angle: convert-angle($angle);
	$color-stops: ();

	@for $i from 1 through length($gradient-colors) {
		$blended-color: blend($blend, nth($gradient-colors, $i), $bg-color);
		$stop: join($blended-color, stop-scale(nth($gradient-stops, $i), $scale), space);
		$color-stops: append($color-stops, $stop, comma);
	}
	@return linear-gradient($css-angle, $color-stops);
}

//Convert angles for css gradients
@function convert-angle($angle) {

	@if $angle == 0 or $angle == 360 {
		@return left;
	} @else if $angle == 45 or $angle == -315 {
		@return left bottom;
	} @else if $angle == 90 or $angle == -270 {
		@return bottom;
	} @else if $angle == 135 or $angle == -225{
		@return right bottom;
	} @else if $angle == 180 or $angle == 180{
		@return right;
	} @else if $angle == -135 or $angle == 225 {
		@return right top;
	} @else if $angle == -90 or $angle == 270 {
		@return top;
	} @else if $angle == -45 or $angle == 315 {
		@return left top;
	} @else {
		@return $angle - 90deg;
	}
}

//Photoshop gradient stop converter
// Used in gradient overlay function
@function stop-scale($stop, $scale) {
	$stop: percentage-to-decimal($stop);
	$new-stop: 0;
	$scale: percentage-to-decimal($scale);

	@return percentage($scale * $stop - (0.5 * ($scale - 1)));
}

//------------------------------------
//    $TYPOGRAPHY
//------------------------------------

//Baseline function. Converts to floated integer.
@function baseline($font-size, $baseline){
	@return ceil($font-size / $baseline) * ($baseline) / $font-size;
}

//Calculate the least-common-denominator between a font-size and a baseline.
@function baseline-lcm($font-size, $line-height){
	$esl: $line-height * $font-size;
	@return lcm( $esl, $base-line-height );
}

// Calculate the baseline of any particular font-size.
@function baseline-calc(
	$font-size: $base-font-size,
	$font-base: $base-font-size,
	$calc-override: false){

	//Easiest measurement of font-size deviation
	$font-ratio: $font-size / $font-base;
	//baseline
	$bl: $type-magic-ratio * $font-base;
	//Every other line.
	$baseline-odd: $base-line-height / 2;
	//Every third line.
	$baseline-odder: $base-line-height / 1.33333;
	$baseline-cache: $bl;

	// Using half-baseline grid for first calculation.
	// This is helpful for smaller font-sizes
	// and gives more leeway with larger ones.

	$baseline: baseline($font-size, $baseline-odd);
	//If this produces either too small or large a line-height,
	// then let's make some corrections.
	// This will only work on fonts larger than the base-font-size unless
	// $calc-override is set to true.
	@if $font-size > $font-base or $calc-override == true {

		//First we can try using every third line.
		@if $baseline > 1.8 or $baseline <= 1.2{
				$baseline-cache: $baseline;
				$baseline: baseline($font-size, $baseline-odder);
		}
		@if $baseline < 1.1 or $baseline > 1.9{
			//If that's not working, let's see if
			// our original value is better by loosening our tolerance.
			@if $baseline-cache > 1.1 and $baseline-cache < 1.9{
				$baseline: $baseline-cache;
			}@else{
				//If both options are bad, then let's use the standard baseline.
				$baseline: baseline($font-size, $base-line-height);
			}
		}
	}
	@return $baseline;
}

//Generates a number based on the typographic grid
@function type-space($multiplier: 2){
	@return $multiplier * $base-line-height;
}

//------------------------------------
//    $MODULAR SCALE
//------------------------------------

// Modular scale function to scale type up or down.
@function modular-scale($i, $scale: $scale-ratio){
	$modular-scale: $scale;
	$stripped-base-font-size:  strip-units($base-font-size) !global;
	@return pow($modular-scale, $i)*($stripped-base-font-size) * 1px;
}

//Get the property of a particular font. e.g.:
// h1{
//    font-size: type(h2, px)
// }
// Would return the pixel value of the h2 font-size.
@function get-type($font-size, $property: 'px'){
	@if $property == 'font-size'{
		$property: 'px';
	}
	@return map-get(map-get($type, $font-size), $property);
}
//ALIAS: shorter name (possibly more confusing)
@function type($font-size, $property: 'px') {
	@return get-type($font-size, $property);
}

//Internal function used for definining the type map.
@function define-type($font-size, $property: 'px', $new-value: "") {
	$target_font: map-get($type, $font-size);
	$target-w-property: map-merge($target_font, ($property : $new-value));
	@return map-merge($type, ($font-size:$target-w-property));
}
