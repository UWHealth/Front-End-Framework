//------------------------------------
//      $MIXINS
//------------------------------------

/* SG
# Tools/Mixins [[dev]]

globals/tools/_t-mixins.scss

##### `@specificity()`
###### mixin(`$increase`: 1)
Specificity increaser. Useful for increasing specificity of a selector instead of using !important

[Reference](http://www.sitepoint.com/selector-specificity-css-preprocessors/)


##### `@opacity()`
###### mixin(`$opacity`)
Cross-browser (including IE8-) opacity.

[Reference](https://gist.github.com/jgv/745754)

##### `@border()`
###### mixin(`$border`)
Allows creating many border properties at once. Works like the standard border shorthand style but allows varied styles on different border directions.

```scss
//scss
.foo {
	@include border(2px 3px solid dashed dotted blue currentColor yellow);
}

//css
.foo {
	border-width: 2px 3px;
	border-style: solid dashed dotted;
	border-color: blue currentColor yellow;
}

```

##### `@button()`
###### mixin(`$bg-color`: `color('links')`, `$text-color`: `null`, `$border`: `null`, `$radius`: `null`, `$text-radius`: `null`, `$style`: `null`, `$inset`: `false`)
Generates common button styles, allowing for simple creation of more complex gradient styles. Intelligently excludes unnecessary styles from states like hover, focus, and active. _Does not generate hover, focus, or active psuedo selectors on its own._

**Accepted arguments:**

* `$bg-color`: Color values. This cannot accept null.
* `$text-color`: Color or null (null will let the mixin decide the best color based on contrast).
* `$border`: Any border properties (colors, styles, widths) or `null`. Uses the `@border()` mixin.
* `$radius`: `border-radius` values. `null` produces no border-radius property.
* `$style`: `null`, `shiny` or `reflective`.
   `shiny` creates a simple gradient backgroud based on the `$bg-color`.
   `reflective` creates a stacked gradient based on the `$bg-color`.
* `$inset`: Boolean. `True` adds a dark box-shadow inset.
   If combined with 'shiny' or 'reflective' `$style`, background gradients are inverted.

##### `@px-to-rems()`, `@rems()`
###### mixin(`$property`, `$sizes`, `$important`: `false`, `$base-font`: `$$base-font-size`)
`REM` generator used to create a property with a `rem` value and `px` fallback.


##### `@font-size()`, `@type-font-size()`
###### mixin(`$font-size`, `$line-height`: `true`, `$font-base`: `$$base-font-size`)
Quickly generate a font-size in rems, with a pixel fallback, based on the value we pass into the mixin. Optionally calculates line-height using `$$base-line-height`.

_`$line-height` also accepts a pixel value and will be converted to a unitless line-height._


##### `@type-space()`
###### mixin(`$properties`, `$multipliers...`, `important`:false)
Output REM values using the typographic grid. This is the prefered method of adding padding and margins because it enforces consistent spacing around all elements.

**Arguments:**
* `$properties`: Can be any `CSS` property that accepts a length value (e.g. `rem`). Also accepts multiple properties as a nested list (e.g. `(padding-left, padding-right)`).
* `$multipliers`: Accepts unitless values that get converted to `rem` units which are a multiple of the typographic grid. Can be multiple values, **separated by spaces**, in the case of `margin` or `padding`.
* `important`: Accepts `true` or `!important`.

```scss
// SCSS input

.foo {
	@include type-space(padding, 1 .25 .5, '!important');
}

// CSS output
.foo {
	padding: 24px 8px 12px 8px !important;
	padding: 1.5rem .375rem .75rem .375rem !important;
}
```

*/


//==========================================================================
// Mixins used for cleaning up and consolodating code
//==========================================================================


//------------------------------------
//    $HELPERS
//------------------------------------

// Specificity increaser
// Useful for increasing specificity of a selector instead of using !important
//
// Taken from: http://www.sitepoint.com/selector-specificity-css-preprocessors/

@mixin specificity($increase: 1) {
	$selector: unquote('&');

	@if $increase > 1 {
		@for $i from 1 to $increase {
			$selector: $selector + unquote('&');
		}
		@at-root #{$selector} {
			@content;
		}
	} @else {
		@content;
	}
}

// Cross-browser (including IE) opacity
// Taken from:
// https://gist.github.com/jgv/745754
@mixin opacity($opacity) {
	// filter: alpha(opactiy=($trans * 100));
	-ms-filter: "progid:DXImageTransform.Microsoft.Alpha(Opacity=#{$opacity * 100})";
	opacity: $opacity;
}

//Better border syntax
//Allows for multiple border properties
// e.g.
//	.foo {
//		@include border(2px 2px solid dashed dotted blue currentColor yellow);
//	}

@mixin border($border) {
	$border-width: ();
	$border-style: ();
	$border-color: ();

	//Make sure border isn't empty
	@if $border != null {
		@each $property in $border {
			//Grab first argument, take the key value in case we're given a map
			$property: nth($property, -1);
			$prop-type: type-of($property);

			//Check property types for types and store them into separate list values
			//Numbers (width), colors (color), or strings (style)
			@if    ($prop-type == 'number')    	{$border-width: append($border-width, $property)}
			@elseif($prop-type == 'color') or
				($property == 'currentColor')	{$border-color: append($border-color, $property)}
			@elseif($prop-type == 'string')		{$border-style: append($border-style, $property)}

		}
	}

	//If this is just a the typical shorthand (width style color)
	// with all values in the correct place, just output the shorthand
	@if length($border-width) == 1
		and length($border-style) == 1
		and length($border-color) == 1
	{
		border: $border-width $border-style $border-color;
	}@else {
	//Else, put them into nested properties and let sass handle the rest
	    border: {
			width: $border-width;
			style: $border-style;
			color: $border-color;
		}
	}
}



//------------------------------------
//    $BUTTONS
//------------------------------------

@mixin button(
    $bg-color: color('links'),
    $text-color: null,
    $border: null,
    $radius: null,
    $style: null,
    $inset: false
){
	//Make if-statements easier to read
	$shiny: ($style == 'shiny');
	//Make sure we don't duplicate styles in psuedo selectors (e.g. hover, active, focus)
	$stateless: (not str-contains('#{&}', ':'));

	//if text color is undefined, set it to type or white
	$text-color: if($text-color, $text-color, black-or-white($bg-color));

	background: $bg-color;
    color: $text-color;
	text-align: if($stateless, center, null);
    text-decoration: none;
	display: if($stateless, inline-block, null);
	@include border($border);
	border-radius: #{$radius};

	//Shiny and reflective button styles

    @if $shiny or $style == 'reflective' {
		//Tone the gradient blending amounts based on type
		$top-blend: if($shiny, 55%, 46%);
        $bottom-blend: if($shiny, 42%, 57%);
		$shadow-blend: 'tint';

		@if $inset {
			//Invert shiny gradients and darken box shadow if inset
			@if $shiny {
				$top-blend-temp: $top-blend;
				$top-blend: $bottom-blend - 2%;
				$bottom-blend: $top-blend-temp;
			}
			$shadow-blend: 'shade';
		}

		$mid-point: if($stateless, 55%, 75%);
		$mid-point: if((not $shiny), (100% - $mid-point), $mid-point);
		//Blend background color with shades of gray, using overlay for a more natural look
		$top-color: blend-overlay($bg-color, hsl(0, 0%, $top-blend));
        $bottom-color: blend-overlay($bg-color, hsl(0, 0%, $bottom-blend));
		$box-shadow: inset 0 .185em .175em call($shadow-blend, $top-color, 30%);


        background-image: linear-gradient(to bottom,
            $top-color 0%, $bg-color $mid-point, $bottom-color 100%);
        filter: progid:DXImageTransform.Microsoft.gradient(startColorStr='#{$top-color}', EndColorStr='#{$bottom-color}');
        box-shadow: $box-shadow;

        @if not $shiny {
			//reflective styles duplicate
            background-size: if($inset, 100% 90%, 100% 60%);
            background-position-y: if($inset, 40%, 110%);
            background-repeat-y: repeat;
        }

    }
}

//------------------------------------
//    $TYPOGRAPHY
//------------------------------------

// REM generator
// Used to create a property with a rem value and PX fallback
@mixin rems($property, $sizes, $important: false, $base-font: $base-font-size) {
	$important_val: '';
	$rem_sizes: null;
	$px_sizes: null;

	@if $important {
		$important_val: ' !important';
	}

	//Loop through sizes, combining them into single lists
	@each $size in $sizes {
		@if $size == ''{
			$size: null;
			$px_sizes: join($px_sizes, $size, space);

		}@else {

			@if $size == 0px {
				$size: 0; //optimization
			}

			$px_sizes: join($px_sizes, $size, space);
			$size: if($size, px-to-rems($size, $base-font), '');
		}
		$rem_sizes: join($rem_sizes, $size, space);
	}

	@if $rem-px-fallback {
		#{$property}: #{$px_sizes}#{$important_val};
	}
	#{$property}: #{$rem_sizes}#{$important_val};

}

//ALIAS: same as above
@mixin px-to-rems($property, $sizes, $important:false, $base-font: $base-font-size){
	@include rems($property, $sizes, $important, $base-font);
}

// Quickly generate a font-size in rems, with a pixel fallback, based on the
// value we pass into the mixin, e.g.:
// h1 {
//     @include type-font-size(24px);
// }
// 1. Set the base element’s `font-size` to the value of your choosing. Set in
//    rems, assuming a browser default of 16px.
// 2. Work out the unitless `line-height` for your project based around your
//    desired `line-height` (defined previously in pixels), and your project’s
//    base font size.

@mixin type-font-size (
		$font-size,
		$line-height: true,
		$font-base: $base-font-size,
		$debug: false
) {
	@if $debug {
		@debug "font-size: #{$font-size}, line-height: #{$line-height}, type: #{type-of($line-height)}";
	}
	//Create REM-based font-size
	@include rems(font-size, $font-size);

	@if $line-height == true {

		$line-height: cache(baseline-calc, $font-size, $font-base);
		line-height: $line-height;

	} @else if type-of($line-height) == "number" {

		//Convert to unitless
		@if not unitless($line-height) {
			@if unit($line-height) == "px" {
				$line-height: $line-height / $font-size;
			}@else {
				@warn "Line-height for #{$font-size} must be unitless or in pixel values";
			}
		}

		line-height: $line-height;

	}
}
//AlIAS
@mixin font-size(
	$font-size,
	$line-height: true,
	$font-base: $base-font-size,
	$debug: false
){
	@include type-font-size($font-size, $line-height, $font-base, $debug);
}

 // Space elements by an amount based on line-height/gutter. Pass in the property
 // to be indented as a paramater and the number of lines to use as an optional paramater, e.g.:
 // pre {
 //     @include type-space(padding-left, 1);
 // }
 // Accepts multiple properties as a nested list.

@mixin type-space($properties, $multipliers.../*important*/) {

	$important: false;
	$multiplier: nth($multipliers, 1);
	$m-length: length($multipliers);

	//Check if multiple arguments have been passed
	@if $m-length > 1 {
		//If so, see if the last argument is $important
		$important_check: nth($multipliers, -1);

		//If last value is $important, then set the $multiplier and $important accordingly
		@if (type-of($important_check) == bool)
		or (type-of($important_check) == string) {
			@if ($important_check == true)
			or (index($important_check, 'i') != null)  {
				$important: true;
				$multiplier: nth($multipliers, 1);
			}
		}
	}

	@each $property in $properties {
		@if length($multiplier) > 1 {
			$values: null;

			@each $multiple in $multiplier {

				$value: $type-magic-number * $multiple;
				//If it's the second or fourth value in a list, give it left/right treatment
				// (multiply by gutter)
				@if ((index($multiplier, $multiple) % 2) == 0) {
					$value: $grid-gutter * $multiple;
				}
				$values: append($values, $value);
			}

			@include rems($property, $values, $important);


		}@else {
			//If multiplier is only 1 value, then do expected stuff
			$value: $type-magic-number * $multiplier;

			//if the value is for right or left spacing, use the gutter width for spacing.
			@if str-contains($property, 'right') or str-contains($property, 'left'){
				$value: $grid-gutter * $multiplier;
			}

			@include rems($property, $value, $important);
		}
	}

}

// Generates Values based on type-scale ($scale-ratio in _config.scss)
// By using @include type-scale([property], [scale number]);.
// This is most useful for font sizing, but can be used for any property
// e.g.: div{
//          @include type-scale(margin-top, 2);}
// Would produce a margin-top value of the second value within your typographic scale.
// If your scale is set to 3,4, your output would be: div{margin-top: 20.63314px; margin-top: 1.4738rem;}

@mixin type-scale($property: "font-size", $mod-scale-value: 1){
	@if $property == "font-size" {
		$font-size: modular-scale($mod-scale-value);
		@include type-font-size($font-size, true);
	}
	@else{
		$scale: modular-scale($mod-scale-value);

		@include rems($property, $scale);
	}
}

@mixin headings-scale($scale: $scale-ratio, $name-space:"") {
	//Checking for floats in $scale
	@if length($scale) == 2{
	// Making sure we don't have a ratio below 1.
		@if nth($scale,1) < nth($scale,2) {
			$scale:   nth($scale, 2)/nth($scale, 1);
		}@else {
			$scale:   nth($scale, 1)/nth($scale, 2);
		}
	}

	@each $heading-number in $type-headings {

		$font-size: modular-scale($heading-number, $scale);
		$current-heading: nth($type-headings,$heading-number);

		%headings_#{$name_space}h#{$current_heading} {
			@include font-size($font_size, true);
			@extend %#{$name_space}space_b !optional;
		}

		h#{$current-heading} {
			@extend %headings_#{$name_space}h#{$current_heading};
		}

		@if $type-scale-classes == true {
			h#{$current-heading},
			.h#{$current-heading} {
				+ p{
					@extend %#{$name-space}space_t_neg !optional;
				}
			}

		}@else {

			h#{$current-heading}, %headings_h#{$current-heading}{
				@include type-font-size($font-size, true);

				+ p{
					@extend %#{$name-space}space_t_neg !optional;
				}
			}
		}
	}

	@if $type-scale-classes == true {
		@each $heading-number in $type-headings{
			$font-size: modular-scale($heading-number, $scale);
			$current-heading: nth($type-headings,$heading-number);

			.h#{$current-heading} {
				@include font-size($font_size, true);
				@extend %#{$name_space}space_b !optional;
			}
		}
	}
}
// Style any number of headings in one fell swoop, e.g.:
//
//	@include headings(1, 3){color:#BADA55;}
//
//	outputs:
//	h1, h2, h3 {color:#BADA55;}
//
// Lifted from inuit.css:
// github.com/csswizardry/inuit.css/generic/_mixins.scss

$headings-use: 0 !global;

@mixin headings($from: 1, $to: 6, $class-type: null) {
	//Used for multiple calls to this mixin.
	// Ensures no double extends.
	$headings-use: $headings-use + 1 !global;

	%base-headings#{$headings-use} {
		@content;
	}

	@if $from >= 1 and $to <= 6{

		@for $i from $from through $to {
			$selector: '#{$class-type}h#{$i}';
			#{$selector} {
				@extend %base-headings#{$headings-use};
			}
		}
	}
	@else {
		@warn "You need to supply numbers between 1 and 6 for headings mixin to work";
	}
}

//------------------------------------
//    $LISTS
//------------------------------------
// http://compass-style.org/reference/compass/typography/lists/
// Turn off the bullet for an element of a list

@mixin no-bullet() {
	list-style-image : none;
	list-style-type  : none;
	margin-left      : 0;
}

// turns off the bullets for an entire list
@mixin no-bullets() {
	list-style: none;
	> li { @include no-bullet; }
}
