/* SG

# Mixins/CSS Helpers [[dev]]

@file globals/tools/_t-mixins.scss

##### `@specificity()`
###### mixin(`$specificity: 1`)
Specificity increaser. Useful for increasing specificity of a selector instead of using `!important`.
```scss
.class {
    @include specificity(2) {
        color: red;
    }
}

//css
.class.class {
    color: red;
}

```
[Reference](http://www.sitepoint.com/selector-specificity-css-preprocessors/)


##### `@opacity()`
###### mixin(`$opacity`)
Cross-browser (including IE8-) opacity.
[Reference](https://gist.github.com/jgv/745754)


##### `@border()`
###### mixin(`$border`)
Allows creating many border properties at once. Works like the standard border shorthand style but allows varied styles on different border directions.

```scss
//scss
.foo {
	@include border(2px 3px solid dashed dotted blue currentColor yellow);
}

//css
.foo {
	border-width: 2px 3px;
	border-style: solid dashed dotted;
	border-color: blue currentColor yellow;
}

```
*/

// Specificity increaser
// Useful for increasing specificity of a selector instead of using !important
//
// Taken from: http://www.sitepoint.com/selector-specificity-css-preprocessors/

@mixin specificity($specificity: 1) {
	$selector: unquote('&');

	@if $specificity > 1 {
		@for $i from 1 to $specificity {
			$selector: $selector + unquote('&');
		}
		@at-root #{$selector} {
			@content;
		}
	} @else {
		@content;
	}
}

// Cross-browser (including IE) opacity
// Taken from:
// https://gist.github.com/jgv/745754
@mixin opacity($opacity) {
	// filter: alpha(opactiy=($trans * 100));
	-ms-filter: "progid:DXImageTransform.Microsoft.Alpha(Opacity=#{$opacity * 100})";
	opacity: $opacity;
}

//Better border syntax
//Allows for multiple border properties
// e.g.
//	.foo {
//		@include border(2px 2px solid dashed dotted blue currentColor yellow);
//	}

@mixin border($border) {
	$border-width: ();
	$border-style: ();
	$border-color: ();

	//Make sure border isn't empty
	@if $border != null {
		@each $property in $border {
			//Grab first argument, take the key value in case we're given a map
			$property: nth($property, -1);
			$prop-type: type-of($property);

			//Check property types for types and store them into separate list values
			//Numbers (width), colors (color), or strings (style)
			@if    ($prop-type == 'number')    	{$border-width: append($border-width, $property)}
			@elseif($prop-type == 'color') or
				($property == 'currentColor')	{$border-color: append($border-color, $property)}
			@elseif($prop-type == 'string')		{$border-style: append($border-style, $property)}

		}
	}

	//If this is just a the typical shorthand (width style color)
	// with all values in the correct place, just output the shorthand
	@if length($border-width) == 1
		and length($border-style) == 1
		and length($border-color) == 1
	{
		border: $border-width $border-style $border-color;
	}@else {
	//Else, put them into nested properties and let sass handle the rest
	    border: {
			width: $border-width;
			style: $border-style;
			color: $border-color;
		}
	}
}

/* SG

# Mixins/Buttons [[dev]]

@file globals/tools/_t-mixins.scss

##### `@button()`
###### mixin(`$bg-color`: `color('links')`, `$text-color`: `null`, `$border`: `null`, `$radius`: `null`, `$text-radius`: `null`, `$style`: `null`, `$inset`: `false`)
Generates common button styles, allowing for simple creation of more complex gradient styles. Intelligently excludes unnecessary styles from states like hover, focus, and active. _Does not generate hover, focus, or active psuedo selectors on its own._

**Accepted arguments**
* `$bg-color`: Color values. This cannot accept null.
* `$text-color`: Color or null (null will let the mixin decide the best color based on contrast).
* `$border`: Any border properties (colors, styles, widths) or `null`. Uses the `@border()` mixin.
* `$radius`: `border-radius` values. `null` produces no border-radius property.
* `$style`: `null`, `shiny` or `reflective`.
   `shiny` creates a simple gradient backgroud based on the `$bg-color`.
   `reflective` creates a stacked gradient based on the `$bg-color`.
* `$inset`: Boolean. `True` adds a dark box-shadow inset.
   If combined with 'shiny' or 'reflective' `$style`, background gradients are inverted.

*/

@mixin button(
    $bg-color: color('links'),
    $text-color: null,
    $border: null,
    $radius: null,
    $style: null,
    $inset: false
){
	//Make if-statements easier to read
	$shiny: ($style == 'shiny');
	//Make sure we don't duplicate styles in psuedo selectors (e.g. hover, active, focus)
	$stateless: (not str-contains('#{&}', ':'));

	//if text color is undefined, set it to type or white
	$text-color: if($text-color, $text-color, black-or-white($bg-color));

	background: $bg-color;
    color: $text-color;
	text-align: if($stateless, center, null);
    text-decoration: none;
	display: if($stateless, inline-block, null);
	@include border($border);
	border-radius: #{$radius};

	//Shiny and reflective button styles

    @if $shiny or $style == 'reflective' {
		//Tone the gradient blending amounts based on type
		$top-blend: if($shiny, 55%, 46%);
        $bottom-blend: if($shiny, 42%, 57%);
		$shadow-blend: 'tint';

		@if $inset {
			//Invert shiny gradients and darken box shadow if inset
			@if $shiny {
				$top-blend-temp: $top-blend;
				$top-blend: $bottom-blend - 2%;
				$bottom-blend: $top-blend-temp;
			}
			$shadow-blend: 'shade';
		}

		$mid-point: if($stateless, 55%, 75%);
		$mid-point: if((not $shiny), (100% - $mid-point), $mid-point);
		//Blend background color with shades of gray, using overlay for a more natural look
		$top-color: blend-overlay($bg-color, hsl(0, 0%, $top-blend));
        $bottom-color: blend-overlay($bg-color, hsl(0, 0%, $bottom-blend));
		$box-shadow: inset 0 .185em .175em call($shadow-blend, $top-color, 30%);


        background-image: linear-gradient(to bottom,
            $top-color 0%, $bg-color $mid-point, $bottom-color 100%);
        filter: progid:DXImageTransform.Microsoft.gradient(startColorStr='#{$top-color}', EndColorStr='#{$bottom-color}');
        box-shadow: $box-shadow;

        @if not $shiny {
			//reflective styles duplicate
            background-size: if($inset, 100% 90%, 100% 60%);
            background-position-y: if($inset, 40%, 110%);
            background-repeat-y: repeat;
        }

    }
}

/* SG
# Mixins/Typography [[dev]]

@file globals/tools/_t-mixins.scss

##### `@px-to-rems()`
###### mixin(`$property`, `$sizes`, `$important`: `false`, `$base-font`: `$$base-font-size`)
Takes a pixel value and creates a property with a `rem` value. If `$$rem-px-fallback` is `true`, a pixel fallback is also included.
@alias `@rems()`

*/

// REM generator
// Used to create a property with a rem value and PX fallback
@mixin px-to-rems($property, $sizes, $important: false, $base-font: $base-font-size) {
	$important_val: '';
	$rem_sizes: null;
	$px_sizes: null;

	@if $important {
		$important_val: ' !important';
	}

	//Loop through sizes, combining them into single lists
	@each $size in $sizes {
		@if $size == ''{
			$size: null;
			$px_sizes: join($px_sizes, $size, space);

		}@else {

			@if $size == 0px {
				$size: 0; //optimization
			}

			$px_sizes: join($px_sizes, $size, space);
			$size: if($size, px-to-rems($size, $base-font), '');
		}
		$rem_sizes: join($rem_sizes, $size, space);
	}

	@if $rem-px-fallback {
		#{$property}: #{$px_sizes}#{$important_val};
	}
	#{$property}: #{$rem_sizes}#{$important_val};

}

//ALIAS: same as above
@mixin rems($property, $sizes, $important:false, $base-font: $base-font-size){
	@include px-to-rems($property, $sizes, $important, $base-font);
}


/* SG
# Mixins/Typography [[dev]]

##### `@type-font-size()`
###### mixin(`$font-size, $line-height: true, $font-base:``$$base-font-size`)
Quickly generate a font-size in rems, with a pixel fallback, based on the value we pass into the mixin. Optionally calculates line-height using `$$base-line-height`.

_`$line-height` also accepts a pixel value and will be converted to a unitless one._

@alias `@font-size()`
@requires `@px-to-rems()`, `cache()`, `baseline-calc()`

*/

@mixin type-font-size (
		$font-size,
		$line-height: true,
		$font-base: $base-font-size,
		$debug: false
) {
	@if $debug {
		@debug "font-size: #{$font-size}, line-height: #{$line-height}, type: #{type-of($line-height)}";
	}
	//Create REM-based font-size
	@include px-to-rems(font-size, $font-size);

	@if $line-height == true {

		$line-height: cache(baseline-calc, $font-size, $font-base);
		line-height: $line-height;

	} @else if type-of($line-height) == "number" {

		//Convert to unitless
		@if not unitless($line-height) {
			@if unit($line-height) == "px" {
				$line-height: $line-height / $font-size;
			}@else {
				@warn "Line-height for #{$font-size} must be unitless or in pixel values";
			}
		}

		line-height: $line-height;

	}
}
//Alias
@mixin font-size($font-size, $line-height:true,$font-base: $base-font-size,$debug: false){
	@include type-font-size($font-size, $line-height, $font-base, $debug);
}

/* SG
# Mixins/Typography [[dev]]

##### `@type-space()`
###### mixin(`$properties, $multipliers, $important: false`)
Output REM values using the typographic grid. This is the prefered method of adding padding and margins because it enforces consistent spacing around all elements.

**Arguments:**
* `$properties`: Can be any `CSS` property that accepts a length value (e.g. `rem`). Also accepts multiple properties as a nested list (e.g. `(padding-left, padding-right)`).
* `$multipliers`: Accepts unitless values that get converted to `rem` units which are a multiple of the typographic grid. Can be multiple values, **separated by spaces**, in the case of `margin` or `padding`.
* `$important`: Accepts `true` or `!important`.

**Example**
```scss
// SCSS input
.foo {
	@include type-space(padding, 1 .25 .5, '!important');
}

// CSS output
.foo {
	padding: 24px 8px 12px 8px !important;
	padding: 1.5rem .375rem .75rem .375rem !important;
}
```

@requires `@px-to-rems()`, `str-contains()`

*/

@mixin type-space($properties, $multipliers, $important: false) {

    $multiplier: nth($multipliers, 1);
    $m-length: length($multipliers);
    $important: if($important, true, false); //Allow for strings, convert to boolean

    @each $property in $properties {
    	$values: null;
    	$multiple-index: 1;

    	@each $multiple in $multipliers {

    		$value: $type-base-unit * $multiple;
    		//If value is the second or fourth value in a list,
            // multiply by the $grid-gutter
    		@if ($multiple-index % 2 == 0) or
    		(
    			str-contains($property, 'right') or
    			str-contains($property, 'left') or
    			str-contains($property, 'width')
    		) {
    			$value: $grid-gutter * $multiple;
    		}
    		$values: append($values, $value);
    		$multiple-index: $multiple-index + 1;
    	}

        @include px-to-rems($property, $values, $important);

    }
}

// Generates Values based on type-scale ($scale-ratio in _config.scss)
// By using @include type-scale([property], [scale number]);.
// This is most useful for font sizing, but can be used for any property
// e.g.: div{
//          @include type-scale(margin-top, 2);}
// Would produce a margin-top value of the second value within your typographic scale.
// If your scale is set to 3,4, your output would be: div{margin-top: 20.63314px; margin-top: 1.4738rem;}

@mixin type-scale($property: "font-size", $mod-scale-value: 1){
	@if $property == "font-size" {
		$font-size: modular-scale($mod-scale-value);
		@include type-font-size($font-size, true);
	}
	@else{
		$scale: modular-scale($mod-scale-value);

		@include px-to-rems($property, $scale);
	}
}

// Style any number of headings in one fell swoop, e.g.:
//
//	@include headings(1, 3){color:#BADA55;}
//
//	outputs:
//	h1, h2, h3 {color:#BADA55;}
//
// Lifted from inuit.css:
// github.com/csswizardry/inuit.css/generic/_mixins.scss

$headings-use: 0 !global;

@mixin headings($from: 1, $to: 6, $class-type: null) {
	//Used for multiple calls to this mixin.
	// Ensures no double extends.
	$headings-use: $headings-use + 1 !global;

	%base-headings#{$headings-use} {
		@content;
	}

	@if $from >= 1 and $to <= 6{

		@for $i from $from through $to {
			$selector: '#{$class-type}h#{$i}';
			#{$selector} {
				@extend %base-headings#{$headings-use};
			}
		}
	}
	@else {
		@warn "You need to supply numbers between 1 and 6 for headings mixin to work";
	}
}

//------------------------------------
//    $LISTS
//------------------------------------
// http://compass-style.org/reference/compass/typography/lists/
// Turn off the bullet for an element of a list

@mixin no-bullet() {
	list-style-image : none;
	list-style-type  : none;
	margin-left      : 0;
}

// turns off the bullets for an entire list
@mixin no-bullets() {
	list-style: none;
	> li { @include no-bullet; }
}
